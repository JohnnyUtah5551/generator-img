import os
import logging
import sqlite3
from datetime import datetime
from telegram import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Update,
    LabeledPrice,
)
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ContextTypes,
    filters,
)
import replicate

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
ADMIN_ID = int(os.getenv("ADMIN_ID", "0"))
RENDER_URL = os.getenv("RENDER_URL")
REPLICATE_API_TOKEN = os.getenv("REPLICATE_API_TOKEN")

# Replicate –∫–ª–∏–µ–Ω—Ç
replicate_client = replicate.Client(api_token=REPLICATE_API_TOKEN)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
DB_FILE = "bot.db"


def init_db():
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY,
            balance INTEGER DEFAULT 3,
            created_at TEXT
        )
    """)
    cur.execute("""
        CREATE TABLE IF NOT EXISTS transactions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            type TEXT,
            amount INTEGER,
            created_at TEXT
        )
    """)
    conn.commit()
    conn.close()


def get_user(user_id: int):
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("SELECT id, balance FROM users WHERE id=?", (user_id,))
    row = cur.fetchone()
    if not row:
        cur.execute(
            "INSERT INTO users (id, balance, created_at) VALUES (?, ?, ?)",
            (user_id, 3, datetime.utcnow().isoformat()),
        )
        conn.commit()
        balance = 3
    else:
        balance = row[1]
    conn.close()
    return balance


def update_balance(user_id: int, delta: int, tx_type: str):
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("UPDATE users SET balance = balance + ? WHERE id=?", (delta, user_id))
    cur.execute(
        "INSERT INTO transactions (user_id, type, amount, created_at) VALUES (?, ?, ?, ?)",
        (user_id, tx_type, delta, datetime.utcnow().isoformat()),
    )
    conn.commit()
    conn.close()


# –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
def main_menu():
    keyboard = [
        [InlineKeyboardButton("üé® –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", callback_data="generate")],
        [InlineKeyboardButton("üí∞ –ë–∞–ª–∞–Ω—Å", callback_data="balance")],
        [InlineKeyboardButton("‚≠ê –ö—É–ø–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏", callback_data="buy")],
        [InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="help")],
    ]
    return InlineKeyboardMarkup(keyboard)


# –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —á–µ—Ä–µ–∑ Replicate —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ñ–æ—Ç–æ
async def generate_image(prompt: str, images: list = None):
    try:
        input_data = {"prompt": prompt}

        # –µ—Å–ª–∏ –µ—Å—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤–æ–µ
        if images and len(images) > 0:
            # images ‚Äî —ç—Ç–æ URL Telegram —Ñ–∞–π–ª–∞
            input_data["image_input"] = images[0]

        output = replicate_client.run(
            "google/nano-banana",
            input=input_data,
        )

        if isinstance(output, list) and len(output) > 0:
            return output[0]
        elif isinstance(output, str):
            return output
        else:
            return None

    except Exception as e:
        error_msg = str(e)
        logger.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {error_msg}")

        if "insufficient credit" in error_msg.lower():
            return {"error": "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π. –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å."}
        elif "flagged as sensitive" in error_msg.lower():
            return {"error": "–ó–∞–ø—Ä–æ—Å –æ—Ç–∫–ª–æ–Ω—ë–Ω —Å–∏—Å—Ç–µ–º–æ–π –º–æ–¥–µ—Ä–∞—Ü–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫—É."}
        else:
            return {"error": "–ò–∑–≤–∏–Ω–∏—Ç–µ, –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞."}


# –°—Ç–∞—Ä—Ç
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    get_user(user_id)

    text = (
        "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å –ø–æ–º–æ—â—å—é "
        "–Ω–µ–π—Ä–æ—Å–µ—Ç–∏ Nano Banana (Google Gemini 2.5 Flash ‚ö°).\n\n"
        "‚ú® –£ —Ç–µ–±—è 3 –±–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏.\n\n"
        "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É ¬´–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å¬ª –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –æ—Ç 1 –¥–æ 4 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å –ø–æ–¥–ø–∏—Å—å—é, "
        "—á—Ç–æ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å, –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ —Ç–µ–∫—Å—Ç, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ."
    )

    await update.message.reply_text(text, reply_markup=main_menu())


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –º–µ–Ω—é
async def menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    try:
        await query.answer()
    except Exception as e:
        if "Query is too old" in str(e):
            logger.warning("–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–π callback query ‚Äî –º–æ–∂–Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å")
        else:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ –Ω–∞ callback: {e}")

    if query.data == "generate":
        await query.message.reply_text(
            "–°–æ–∑–¥–∞–≤–∞–π—Ç–µ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—Ä—è–º–æ –≤ —á–∞—Ç–µ.\n\n"
            "–î–ª—è –≤–∞—Å —Ä–∞–±–æ—Ç–∞–µ—Ç Google Gemini 2.5 Flash ‚Äî –æ–Ω–∞ –∂–µ Nano Banana üçå\n\n"
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ—Ç 1 –¥–æ 4 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å –ø–æ–¥–ø–∏—Å—å—é, —á—Ç–æ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å, –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ —Ç–µ–∫—Å—Ç."
        )
        await query.message.delete()

    elif query.data == "balance":
        balance = get_user(query.from_user.id)
        await query.message.reply_text(f"üí∞ –£ –≤–∞—Å {balance} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.", reply_markup=main_menu())

    elif query.data == "buy":
        keyboard = [
            [InlineKeyboardButton("10 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π ‚Äî 40‚≠ê", callback_data="buy_10")],
            [InlineKeyboardButton("50 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π ‚Äî 200‚≠ê", callback_data="buy_50")],
            [InlineKeyboardButton("100 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π ‚Äî 400‚≠ê", callback_data="buy_100")],
        ]
        await query.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç:", reply_markup=InlineKeyboardMarkup(keyboard))

    elif query.data == "help":
        help_text = (
            "‚ÑπÔ∏è –ß—Ç–æ–±—ã —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, —Å–Ω–∞—á–∞–ª–∞ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É ¬´–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å¬ª.\n\n"
            "–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –æ—Ç 1 –¥–æ 4 –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å –ø–æ–¥–ø–∏—Å—å—é, —á—Ç–æ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å, "
            "–∏–ª–∏ –ø—Ä–æ—Å—Ç–æ —Ç–µ–∫—Å—Ç –¥–ª—è –Ω–æ–≤–æ–π –∫–∞—Ä—Ç–∏–Ω–∫–∏.\n\n"
            "üí∞ –î–ª—è –ø–æ–∫—É–ø–æ–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è Telegram Stars."
        )
        await query.message.reply_text(help_text, reply_markup=main_menu())


# –ü–æ–∫—É–ø–∫–∏
async def buy_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    package_map = {
        "buy_10": (10, 40),
        "buy_50": (50, 200),
        "buy_100": (100, 400),
    }

    if query.data in package_map:
        gens, stars = package_map[query.data]
        await query.message.reply_invoice(
            title="–ü–æ–∫—É–ø–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π",
            description=f"{gens} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π –¥–ª—è –Ω–µ–π—Ä–æ—Å–µ—Ç–∏",
            payload=f"buy_{gens}",
            provider_token="stars",  # ‚ö° –≤–æ—Ç –∫–ª—é—á–µ–≤–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
            currency="XTR",
            prices=[LabeledPrice(label=f"{gens} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π", amount=stars)],
            start_parameter="stars-payment",
        )


# –û–±—Ä–∞–±–æ—Ç–∫–∞ —É—Å–ø–µ—à–Ω–æ–π –æ–ø–ª–∞—Ç—ã
async def successful_payment_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    payment = update.message.successful_payment
    user_id = update.effective_user.id

    gens_map = {
        "buy_10": 10,
        "buy_50": 50,
        "buy_100": 100,
    }

    gens = gens_map.get(payment.invoice_payload, 0)
    if gens > 0:
        update_balance(user_id, gens, "buy")
        await update.message.reply_text(
            f"‚úÖ –û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ! –ù–∞ –≤–∞—à –±–∞–ª–∞–Ω—Å –¥–æ–±–∞–≤–ª–µ–Ω–æ {gens} –≥–µ–Ω–µ—Ä–∞—Ü–∏–π.",
            reply_markup=main_menu()
        )


# –°–æ–æ–±—â–µ–Ω–∏—è —Å —Ç–µ–∫—Å—Ç–æ–º / —Ñ–æ—Ç–æ
import io
import base64
import httpx
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes

# ADMIN_ID —É–∂–µ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –≤ –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
# ADMIN_ID = int(os.getenv("ADMIN_ID", "0"))

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    balance = get_user(user_id)

    if user_id != ADMIN_ID and balance <= 0:
        await update.message.reply_text(
            "‚ö†Ô∏è –£ –≤–∞—Å –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏. –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å —á–µ—Ä–µ–∑ –º–µ–Ω—é.",
            reply_markup=main_menu()
        )
        return

    prompt = update.message.caption or update.message.text
    if not prompt:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–æ–±–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏.")
        return

    progress_msg = await update.message.reply_text("‚è≥ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...")

    # --- –û–ë–†–ê–ë–û–¢–ö–ê –§–û–¢–û --- #
    images_inputs = []
    if update.message.photo:
        # –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ —Å–∞–º–æ–µ –∫—Ä—É–ø–Ω–æ–µ —Ñ–æ—Ç–æ (–ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤ —Å–ø–∏—Å–∫–µ)
        photo = update.message.photo[-1]
        file = await photo.get_file()  # <- —Ç–µ–ø–µ—Ä—å await –≤–Ω—É—Ç—Ä–∏ async
        images_inputs.append(file.file_path)  # –ø–µ—Ä–µ–¥–∞–µ–º URL –≤–º–µ—Å—Ç–æ –±–∞–π—Ç–æ


    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ Replicate
result = await generate_image(prompt, images_inputs[0] if images_inputs else None)

await progress_msg.delete()

if isinstance(result, dict) and "error" in result:
    await update.message.reply_text(result["error"])
    return

if result:  # result —É–∂–µ URL
    async with httpx.AsyncClient() as client:
        img_bytes = (await client.get(result)).content
    await update.message.reply_photo(img_bytes)
else:
    await update.message.reply_text("‚ö†Ô∏è –ò–∑–≤–∏–Ω–∏—Ç–µ, –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.")
    return

if user_id != ADMIN_ID:
    update_balance(user_id, -1, "spend")

keyboard = [
    [
        InlineKeyboardButton("üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å", callback_data="generate"),
        InlineKeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å", callback_data="end"),
    ]
]
await update.message.reply_text(
    "–ù–∞–ø–∏—à–∏—Ç–µ –≤ —á–∞—Ç, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å —á—Ç–æ-—Ç–æ –µ—â—ë.",
    reply_markup=InlineKeyboardMarkup(keyboard),
)

            
# –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–µ—Å—Å–∏–∏
async def end_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.message.reply_text("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=main_menu())


# –û—Ç—á—ë—Ç—ã –¥–ª—è –∞–¥–º–∏–Ω–∞
async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return

    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("SELECT COUNT(*), SUM(balance) FROM users")
    users_count, total_balance = cur.fetchone()
    cur.execute("SELECT SUM(amount) FROM transactions WHERE type='buy'")
    total_bought = cur.fetchone()[0] or 0
    cur.execute("SELECT SUM(amount) FROM transactions WHERE type='spend'")
    total_spent = abs(cur.fetchone()[0] or 0)
    conn.close()

    text = (
        f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n\n"
        f"üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {users_count}\n"
        f"üí∞ –°—É–º–º–∞—Ä–Ω—ã–π –±–∞–ª–∞–Ω—Å: {total_balance}\n"
        f"‚≠ê –ö—É–ø–ª–µ–Ω–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π: {total_bought}\n"
        f"üé® –ò–∑—Ä–∞—Å—Ö–æ–¥–æ–≤–∞–Ω–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π: {total_spent}"
    )
    await update.message.reply_text(text)


# –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
def main():
    init_db()
    app = Application.builder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("stats", stats))
    app.add_handler(CallbackQueryHandler(menu_handler, pattern="^(generate|balance|buy|help)$"))
    app.add_handler(CallbackQueryHandler(buy_handler, pattern="^(buy_10|buy_50|buy_100)$"))
    app.add_handler(CallbackQueryHandler(end_handler, pattern="^end$"))
    app.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, successful_payment_handler))
    app.add_handler(MessageHandler(filters.TEXT | filters.PHOTO, handle_message))

    port = int(os.environ.get("PORT", 5000))
    app.run_webhook(
        listen="0.0.0.0",
        port=port,
        url_path=TOKEN,
        webhook_url=f"{RENDER_URL}/{TOKEN}"
    )


if __name__ == "__main__":
    main()







